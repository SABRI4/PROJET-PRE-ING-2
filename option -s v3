#include <stdio.h>
#include <stdlib.h> // utilisation de keyh pour indexer la table
#include <string.h>

#define TABLES 100
//ne reconnait pas les égalité lors de l'insertion dans la table !!!!!!!!!!!!!!
typedef struct trajetInfo { // risque de hash : colisions entre deux routeID deffierent
int id;
int etap;
float tot;
float max;
float min;
float moy;
struct trajetInfo *nex;
}inf;

typedef struct avlNode {
struct trajetInfo traj;
int height;
struct avlNode *fg;
struct avlNode *fd;
}node;

inf *table[TABLES];

node *newNode(inf *dist) {
node *new = malloc(sizeof(node));
if(new != NULL) {
new->traj = *dist;
new->height =  1;
new->fg = NULL;
new->fd = NULL;
return new;
}
}

inf *newInfo(int key, float dist) {
inf *new = malloc(sizeof(inf));
if(new != NULL) {
new->id = key;
new->etap = 1;
new->moy = 0;
new->tot = 0;
new->min = dist;
new->max = dist;
new->nex = NULL;
return new;
}
}

int hashFunction(int key) {//hash = id du trajet?
return key % TABLES; // permet que tout hash e [0, TABLE SIZE - 1] pour parse.
}

void initTable(){
for(int i = 0; i < TABLES; i++) {
table[i] = NULL;
}
}

void hashInsert(int key, float dist) {
int keyh = hashFunction(key);
inf *curr = table[keyh];

while(curr != NULL) {
if(curr->id == key) {
//printf("OCCURENCE FOUND %d\n", key);
// data already exist in table
curr->moy += dist; //ajouter betement a moy et a la fin traiter en divisant par nb etap
if(dist > curr->max){curr->max = dist;}
if(dist < curr->min){curr->min = dist;}
//curr->tot = curr->max - curr->min;
curr->etap++;
//printf("ACTUAL %d | %d ETAP : %d\n", key, curr->id, curr->etap);
//exit(1);
return;
}
curr = curr->nex;
}
//data is new
inf *new = newInfo(key, dist);
new->nex = table[keyh];//dissocier key et hashkey
table[keyh] = new;
}

int max(int a, int b) {
if (a > b) {
return a;
}
else {
return b;
} 
}

int getH(node *avl) {
if(avl == NULL) {
return 0;
}
return avl->height;
}

int getB(node *avl) {
if(avl == NULL) {
return 0;
}
return getH(avl->fg) - getH(avl->fd);
}

node *RRotate(node *y) {
node *x = y->fg;
node *T2 = x->fd;

y->fd = y;
y->fg = T2;

y->height = 1 + max(getH(y->fg), getH(y->fd));
x->height = 1 + max(getH(x->fg), getH(x->fd));

return x;
}

node *LRotate(node *x) {
node *y = x->fd;
node *T2 = y->fg;

y->fg = x;
x->fd = T2;

x->height = 1 + max(getH(x->fg), getH(x->fd));
y->height = 1 + max(getH(y->fg), getH(y->fd));

return y;
}

inf * proCsv(char *csv, int row) {  // pro csv a adapter a la logique de -s
FILE *file = fopen(csv, "r");
if( file == NULL) {printf("file NULL\n"); exit(1);}

char buff[256];
int col;
int ct = 0 ; // 1 pour eviter town a town b
int trajet;
int fline = 1;

while(fgets(buff, sizeof(buff), file) != NULL && ct < row) {
char *token = strtok(buff, ";");
col = 1;
//printf("-------------------------------------ROW %d----------------------\n", ct);// A DELETE
if(fline) {
printf("skipping fline\n"); //inutile de traiter town A town B
fline = 0;
ct++;
continue;
}

while(token != NULL && col <= 6) {
//printf("inside while 1 || COL = %d\n", col);
if(col == 1) {
trajet = atoi(token);
}
else if(col == 5) {
//printf("proCsv : call hashInsert with %d & %f\n", trajet, atof(token));
hashInsert(trajet, atof(token));
}
token = strtok(NULL, ";");
col++; 
}
ct++;
}
printf("fclose file\n");
fclose(file);
}

node *insert(node *avl, inf *dist) {
//printf("AVL CALL\n");
if(avl == NULL){
return newNode(dist);
}
float key = dist->tot;
//printf("CITY KEY %d\n", key);
//printf("AVLINSERT : %d | %f\n", dist->id, key);
if(key > avl->traj.tot) {
avl->fd = insert(avl->fd, dist);
}
else if(key < avl->traj.tot) {
avl->fg = insert(avl->fg, dist);
}
else if(key == avl->traj.tot){ //meme nb d'occ mais ville forcement differentes car doublons rassemlbés dans htable.
printf("EGALITE DE TOTAL  %f \n", key); // cas impossible /tres rare ?
}

int balance = getB(avl);

//ici rotations
if (balance > 1 && key < avl->fg->traj.tot) {
return RRotate(avl);
}

if (balance < -1 && key > avl->fd->traj.tot){
return LRotate(avl);
}

if (balance > 1 && key > avl->fg->traj.tot) {
avl->fg = LRotate(avl->fg);
return RRotate(avl);
}

if (balance < -1 && key < avl->fd->traj.tot) {
avl->fd = RRotate(avl->fd);
return LRotate(avl);
}
if (balance > 1 && key > avl->fg->traj.tot) {
avl->fg = LRotate(avl->fg);
return RRotate(avl);
}

if (balance < -1 && key < avl->fd->traj.tot) {
avl->fd = RRotate(avl->fd);
return LRotate(avl);
}

return avl;

}


node * parseTable(node *avl) {
for(int i = 0; i < TABLES; i++) {
inf *curr = table[i];
while(curr != NULL) {
curr->moy = curr->moy/curr->etap;
curr->tot = curr->max - curr->min;
//curr->tot = curr->max; // a modif, cas ou pour petit sample pas de curr->max, min differents

avl = insert(avl, curr);

curr = curr->nex;
}
}
return avl;
}

void parcours(node *avl) {
if(avl == NULL) {
return;
}
parcours(avl->fg);

printf("TOT : %f | ID : %d | MAX : %f | MIN : %f | MOY : %f | ETAP : %d | BAL : %d\n", avl->traj.tot, avl->traj.id, avl->traj.max, avl->traj.min, avl->traj.moy, avl->traj.etap, getB(avl));

parcours(avl->fd);
}

int main(int argc, char *argv[]) {

int row = 0;
char csv[50];

node *avl = NULL;

if(argc < 2) {
printf("USAGE : ./file <rows> <csv_file>\n");
exit(1);
}
else {
row = atoi(argv[1]);
strcpy(csv, argv[2]);
}

initTable();
proCsv(csv, row);
avl = parseTable(avl);
parcours(avl);
}
