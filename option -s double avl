#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

typedef struct cityInfo {
char *ville;
int asc;
int occ; 
int occd;
}inf;

typedef struct avlNode {
int key;
struct cityInfo inf;
int height;
int gocc;
struct avlNode *fg;
struct avlNode *fd;
inf *tabAsc;
int *tabOccd
int tabSize;
}node;


node *newNode(inf *city) {
node *new = malloc(sizeof(node));
if(new != NULL) {
new->inf = *city;
new->gocc = city->occ;
new->tabSize = 1;
new->height =  1;
new->fg = NULL;
new->fd = NULL;
return new;
}
}
inf *newInfo(char *city, int occd) {
inf *new = malloc(sizeof(inf));
if(new != NULL) {
strcpy(new->ville, city);
new->asc = getAsc(city);
new->occd = occd;
new->occ = 1;
return new;
}
}

int getAsc(char *city) {
    int length = sizeof(city) - 1; 
    for (int i = 0; i < length; i++) {
        int asciiValue = (int)myString[i];
    }
    return asciiValue;
}

int max(int a, int b) {
if (a > b) {
return a;
}
else {
return b;
} 
}

int getH(node *avl) {
if(avl == NULL) {
return 0;
}
return avl->height;
}

int getB(node *avl) {
if(avl == NULL) {
return 0;
}
return getH(avl->fg) - getH(avl->fd);
}

node *RRotate(node *y) {
node *x = y->fg;
node *T2 = x->fd;

y->fd = y;
y->fg = T2;

y->height = 1 + max(getH(y->fg), getH(y->fd));
x->height = 1 + max(getH(x->fg), getH(x->fd));

return x;
}

node *LRotate(node *x) {
node *y = x->fd;
node *T2 = y->fg;

y->fg = x;
x->fd = T2;

x->height = 1 + max(getH(x->fg), getH(x->fd));
y->height = 1 + max(getH(y->fg), getH(y->fd));

return y;
}

node *insert(node *avl, inf *city) {
    if(avl == NULL) {
        return newNode(city);
    }
    
    int key = getAsc(city->ville);
    
    if(key > avl->inf.asc) {
        insert(avl->fd, city);
    }
    else if(key < avl->inf.asc) {
        insert(avl->fg, city);
    }
    else if(key == avl->inf.asc) {
        //cas d'égalité
        avl->inf.occ++;
        if(occd) {avl->inf.occd++;}
    }
    
    int balance = getB(avl);

//ici rotations
if (balance > 1 && key < avl->fg->info.occ) {
return RRotate(avl);
}

if (balance < -1 && key > avl->fd->info.occ){
return LRotate(avl);
}

if (balance > 1 && key > avl->fg->info.occ) {
avl->fg = LRotate(avl->fg);
return RRotate(avl);
}

if (balance < -1 && key < avl->fd->info.occ) {
avl->fd = RRotate(avl->fd);
return LRotate(avl);
}
if (balance > 1 && key > avl->fg->info.occ) {
avl->fg = LRotate(avl->fg);
return RRotate(avl);
}

if (balance < -1 && key < avl->fd->info.occ) {
avl->fd = RRotate(avl->fd);
return LRotate(avl);
}

return avl;
}

inf * proCsv(char *csv, int row, node *avl) {
FILE *file = fopen(csv, "r");
if( file == NULL) {printf("file NULL\n"); exit(1);}

char buff[256];
int col;
int ct = 0 ; // 1 pour eviter town a town b
int step;
int fline = 1;

while(fgets(buff, sizeof(buff), file) != NULL && ct < row) {
char *token = strtok(buff, ";");
col = 1;
//printf("-------------------------------------ROW %d----------------------\n", ct);// A DELETE
if(fline) {
printf("skipping fline\n");
fline = 0;
ct++;
continue;
}

while(token != NULL && col <= 6) {
//printf("inside while 1 || COL = %d\n", col);
if(col == 2) {
step = atoi(token);
}
else if(col == 3 || col == 4) {
if(step == 1 && col == 3) {//logique d'ajt en cas de ville1 == épart
//printf("bef process 1, 1\n");
inf *city = newNode(token, 1);
avl = insert(avl, city);
}
else {
//printf("bef process 1, 0\n");
inf *city = newNode(token, 0);
avl = insert(avl, city);
}
}
token = strtok(NULL, ";");
col++; 
}
ct++;
}
printf("fclose file\n");
fclose(file);
return avl;
}

node *insert2(node *avl, inf *city) {
    if(avl == NULL) {
        return newNode(city->ville);
    }
    
    int key = city->occ;
    
        if(key > avl->gocc) {
        insert(avl->fd, city);
    }
    else if(key < avl->gocc) {
        insert(avl->fg, city);
    }
    else if(key == gocc) {
        //cas de valeur occ déja présente
        //avl tabsize = 0
        avl->tabAsc[avl->tabSize] = city;
        avl->tabOccd[avl->tabSize] = city->occd;
        avl->tabSize++;
    }
    
        int balance = getB(avl);

//ici rotations
if (balance > 1 && key < avl->fg->info.occ) {
return RRotate(avl);
}

if (balance < -1 && key > avl->fd->info.occ){
return LRotate(avl);
}

if (balance > 1 && key > avl->fg->info.occ) {
avl->fg = LRotate(avl->fg);
return RRotate(avl);
}

if (balance < -1 && key < avl->fd->info.occ) {
avl->fd = RRotate(avl->fd);
return LRotate(avl);
}
if (balance > 1 && key > avl->fg->info.occ) {
avl->fg = LRotate(avl->fg);
return RRotate(avl);
}

if (balance < -1 && key < avl->fd->info.occ) {
avl->fd = RRotate(avl->fd);
return LRotate(avl);
}

return avl;
    
}

node *parseTable(node *avl, node *avl2) {
    if(avl == NULL) {
        return NULL;
    }
    parseTable(avl->fg);
    avl2 = insert2(avl2, avl->inf);
    parseTable(avl->fd);
    
    return avl2;
}

node *adjust(node *avl) { // a faire sur le premier avl
    adjust(avl->fg);
    
    int occd = avl->inf.occd;
    int occ = avl->inf.occ;
    
    int nocc = (occ - occd)/2;
    nocc += occd;
    avl->inf.occ = nocc;
    
    adjust(avl->fd);

    
    return avl;
}

void parcours(node *avl) {
    parcours(avl->fg);
    
    printf("main city : %s | occNode : %d | occInf : %d | main occd %d\n"; avl->inf.city, avl->gocc, avl->city.occ, avl->city.occd);
    for(int i = 0; i < tabSize; i++) {
        printf("idx : %d | city : %s | occd : %d\n", i, avl->tabAsc[i].ville, avl->tabOccd[i]);
    }
    
    parcours(avl->fd);
    
}

int main()
{
int row = 0;
char csv[50];

node *avl = NULL;
node *avl2 = NULL;

if(argc < 2) {
printf("USAGE : ./file <rows> <csv_file>\n");
exit(1);
}
else {
row = atoi(argv[1]);
strcpy(csv, argv[2]);
}

avl = proCsv(csv, row, avl);
avl = adjust(avl);
avl2 = parseTable(avl, avl2);
parcours(avl2);

}
